#lang racket

(provide 
 get-tile
 for-tile
 ascend
 descend
 get-npcs
 update-npcs)

(require
 noise
 thing
 (only-in racket/gui queue-callback)
 "point.rkt"
 "entities.rkt"
 "items.rkt"
 "animate.rkt")

; Level defintions
; tile-gen : x y -> tile
; npc-gen  : x y -> npc or #f
; item-gen : x y -> item or #f
(define-struct level-definition (tile-gen npc-gen item-gen))

; All levels 
; (pt x y) : tile
; 'npcs    : list of npcs
; 'gen     ; level definition (see above)
; 'seed    ; a random seed [0,1) generated once per level
(define levels (make-hasheq))
(define current-depth (make-parameter 0))

; Generate a new level (if it doesn't already exist)
(define (get-level depth)
  (unless (hash-has-key? levels depth)
    (define level (make-hash))
    (hash-set! level 'seed (random))
    (hash-set! level 'npcs '())
    (hash-set! level 'gen
      (cond
        [(= depth 0) 
         bugs
         (level-definition surface nothing nothing)]
        [else
         (case (random 4)
           [(0) (level-definition shallow-cave rats-and-bombs base-items)]
           [(1) (level-definition daedalus maze-baddies base-items)]
           [(2) (level-definition cellular goblin-warren base-items)]
           [(3) (level-definition bugs goblin-warren base-items)])]))
    (hash-set! levels depth level))
  (hash-ref levels depth))

; Loop over all generated tiles on the current level to update them
; f : x y tile -> void
(define (for-tile f)
  (for ([(pt tile) (in-hash (get-level (current-depth)))]
        #:when (pt? pt))
    (f (pt-x pt) (pt-y pt) tile)))

; Ascend or descend to a (potentially) new level
(define (ascend) (current-depth (+ (current-depth) 1)))
(define (descend) (current-depth (- (current-depth) 1)))

; Get the NPCs on the current level
(define (get-npcs)
  (hash-ref (get-level (current-depth)) 'npcs))

; Update npcs
(define (update-npcs world)
  (define current-level (get-level (current-depth)))
  (define npcs (hash-ref current-level 'npcs))
  
  ; Allow each to move
  (for ([npc (in-list npcs)])
    (thing-call npc 'act npc world))
  
  ; Check for (and remove) any dead npcs
  (hash-set! current-level 'npcs
    (filter 
     (lambda (npc)
       (when (<= (thing-get npc 'health) 0)
         (send world log (format "~a has died" (thing-get npc 'name))))
       (> (thing-get npc 'health) 0))
     npcs)))

; Fetch a tile
(define (get-tile x y)
  (define current-level (get-level (current-depth)))
  (define seed (hash-ref current-level 'seed))
  
  ; If the tile doesn't already exist, generate it
  (unless (hash-has-key? current-level (pt x y))
    ; Get the new tile
    ; Copy the tile here so that they don't share state
    (define new-tile 
      (let ([base-tile ((level-definition-tile-gen (hash-ref current-level 'gen)) seed x y)])
        (make-thing base-tile)))
    (hash-set! current-level (pt x y) new-tile) 
    
    ; NPCs and items are only on walkable tiles
    (when (thing-get new-tile 'walkable)
      ; (Potentially) generate a new npc
      (define new-npc ((level-definition-npc-gen (hash-ref current-level 'gen)) seed x y))
      (when (and (not (void? new-npc)) new-npc)
        (let ([new-npc (make-thing new-npc [location (pt x y)])])
          (hash-set! current-level 'npcs (cons new-npc (hash-ref current-level 'npcs)))))
      
      ; (Potentially) generate a new item for that tile
      ; Do not generate an item if there already is one (generated by the tile generation routine)
      (when (null? (thing-get new-tile 'items '()))
        (define new-item ((level-definition-item-gen (hash-ref current-level 'gen)) seed x y))
        (when (and (not (void? new-item)) new-item)
          (let ([new-item (make-thing new-item)])
            (thing-set! new-tile 'items (cons new-item (thing-get new-tile 'items))))))))
  
  ; Return the tile (newly generated or not)
  (hash-ref current-level (pt x y)))

; Look up a thing from a vector by 'name
(define (lookup vec name)
  (let/ec return
    (for ([thing vec]
          #:when (equal? name (thing-get thing 'name #f)))
      (return thing))
    (return #f)))
                
; ===== Basic tile definitions =====

(define-thing tile
  [character #\space]
  [color "black"]
  [items '()]
  [lighting 'dark]    ; Dark: Invisible; Fog: Only show tile, not NPC or item; Lit: Everything
  [walkable #f]       ; Can the player walk on this tile?
  [solid #f]          ; Does this tile block light?
  )

(define-thing empty tile
  [walkable #t])

(define-thing grass tile
  [character #\.]
  [color "green"]
  [walkable #t])

(define-thing wall tile
  [solid #t]
  [character #\#]
  [color "white"])

(define-thing water tile
  [character #\u00db]
  [color "blue"])

(define-thing tree tile
  [solid #t]
  [character #\u0005]
  [color "green"])

(define-thing stairs-up tile
  [character #\<]
  [color "gold"]
  [walkable #t]
  [(on-enter entity world)
   (when (eq? (send world get-player) entity)
     (ascend)
     (hash-set! (get-level (current-depth)) 
                (thing-get (send world get-player) 'location)
                (make-thing stairs-up)))])

(define-thing stairs-down tile
  [character #\>]
  [color "gold"]
  [walkable #t]
  [(on-enter entity world)
   (when (eq? (send world get-player) entity)
     (descend)
     (hash-set! (get-level (current-depth)) 
                (thing-get (send world get-player) 'location)
                (make-thing stairs-up)))])

; ===== Tile generation routines =====

; The surface level with grass, water, and trees
(define (surface seed x y)
  (define water? (> (simplex (* 0.1 x) seed      (* 0.1 y)) 0.5))
  (define tree?  (> (simplex seed      (* 0.1 x) (* 0.1 y)) 0.5))
  (cond
    [water? (make-thing water)]
    [tree?  (make-thing tree)]
    [else   (if (zero? (random 1000)) stairs-down grass)]))

; Generate a simple cave with water and trees
(define (shallow-cave seed x y)
  (define wall?  (> (simplex (* 0.1 x) (* 0.1 y) seed)      0))
  (define water? (> (simplex (* 0.1 x) seed      (* 0.1 y)) 0.5))
  (define tree?  (> (simplex seed      (* 0.1 x) (* 0.1 y)) 0.5))
  (cond
    [wall?  (make-thing wall)]
    [water? (make-thing water)]
    [tree?  (make-thing tree)]
    [else   (if (zero? (random 1000)) stairs-down empty)]))

; Generate a series of straight lines
(define (daedalus seed x y)
  ; Guaranteed wall if not x or y = 5 +- 1 (mod 10)
  (define maybe-hall?
    (or (<= 4 (remainder (abs x) 10) 6)
        (<= 4 (remainder (abs y) 10) 6)))
  
  ; Maybe a stairway if both are five
  (define maybe-stairs?
    (= 5 (remainder (abs x) 10) (remainder (abs y) 10)))
  
  ; Find the endpoints
  (define xlo (floor (/ x 10)))
  (define ylo (floor (/ y 10)))
  
  ; Calculate if we'd have an open space
  (define good-hall?
    (or (and (> (simplex (* 0.5 xlo)       (* 0.5 ylo)       seed) -0.25)
             (> (simplex (* 0.5 (+ xlo 1)) (* 0.5 ylo)       seed) -0.25))
        (and (> (simplex (* 0.5 xlo)       (* 0.5 ylo)       seed) -0.25)
             (> (simplex (* 0.5 xlo)       (* 0.5 (+ ylo 1)) seed) -0.25))))
  
  ; Figure out which case we have
  (cond
    ; Central section
    [(and (<= -3 x 3) (<= -3 y 3))
     (make-thing empty)]
    ; Guaranteed path
    [(and maybe-hall? good-hall?) 
     ; Check for stairs
     (if (and maybe-stairs? (zero? (random 10)))
         (make-thing stairs-down)
         (make-thing empty))]
    ; Wall
    [else
     (make-thing wall)]))

; Use a cellular automaton to generate levels
(define (cellular seed x y)
  ; Get the current level
  (define current-level (get-level (current-depth)))
  
  ; Helper to count neighboring grass tiles
  (define (grass? at) 
    (eq? #\. (thing-get (hash-ref current-level at empty) 'character #\space)))
  (define (count at)
    (for*/sum ([xi (in-range -1 2)] 
               [yi (in-range -1 2)]
               #:unless (= 0 xi yi))
      (if (grass? (+ at (pt xi yi))) 1 0)))
  
  ; Now randomly set some percentage of the surrounding tiles
  (define region-size 10)
  
  ; Clear the area first
  (for* ([xi (in-range (- x region-size) (+ x region-size 1))]
         [yi (in-range (- y region-size) (+ y region-size 1))])
    (hash-set! current-level (pt xi yi) (make-thing wall)))
  
  ; Set the center tile
  (hash-set! current-level (pt x y) (make-thing grass))
  
  ; Random grow
  (for ([i (in-range (* region-size region-size region-size))])
    ; Choose a random point from the nearby area
    (define new-pt (+ (pt x y)
                      (pt (- (random (* region-size 2)) region-size)
                          (- (random (* region-size 2)) region-size))))
    
    ; Set the new tile if we have 3 or less neighbors
    ; And this tile hasn't already been set
    ; Some become stairs instead
    (when (<= 1 (count new-pt) 2)
      (hash-set! current-level new-pt 
                 (if (zero? (random 100))
                     (make-thing stairs-up)
                     (make-thing grass)))))
  
  ; Return our tile
  (hash-ref current-level (pt x y))) 

; Generate levels using skittering bugs
(define (bugs seed x y)
  (define current-level (get-level (current-depth)))
  
  ; When a tile is requested, spread out from it for a while
  (let loop ([i 0] [x x] [y y])
    (define at (pt x y))
    
    ; Clear unset neighbors
    (for* ([xi (in-range -1 2)] [yi (in-range -1 2)])
      (define ati (+ at (pt xi yi)))
      (when (not (hash-has-key? current-level ati))
        (hash-set! current-level ati (make-thing wall))))
    
    ; Set the current tile
    (hash-set! current-level at 
               (if (zero? (random 100))
                   (make-thing stairs-up)
                   (make-thing grass)))
    
    ; Wonder around
    (when (< i 10)
      (loop (+ i 1) (+ x (random 3) -1) (+ y (random 3) -1))))
  
  ; Return the tile
  (hash-ref current-level (pt x y)))
                 

; ===== NPC generation routines =====

; No NPCs (also works for items)
(define (nothing seed x y) #f)

; Rats. All of the rats.
(define (rats-only seed x y)
  (when (zero? (random 100))
    (lookup *entities* "rat")))

; Rats and bombs
(define (rats-and-bombs seed x y)
  (when (zero? (random 75))
    (lookup *entities* (if (zero? (random 2)) "rat" "bomb"))))

; Maze baddies
(define (maze-baddies seed x y)
  (when (zero? (random 75))
    (case (random 5)
      [(0) 
       (lookup *entities* "minotaur")]
      [(1 2 3)
       (lookup *entities* "rat")]
      [(4)
       (lookup *entities* "spider")])))

; Goblins
(define (goblin-warren seed x y)
  (when (zero? (random 100))
    (lookup *entities* "goblin")))

; ===== item generation routines =====

; Only basic items
(define (base-items seed x y)
  (when (zero? (random 1000))
    (case (random 4)
      [(0) (lookup *armors* "leather")]
      [(1) (lookup *weapons* "club")]
      [(2) (lookup *potions* "health potion")]
      [(3) (lookup *coins* "copper coin")])))